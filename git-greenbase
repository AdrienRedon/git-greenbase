#!/bin/bash

if [[ ${GREENBASE_DEBUG-false} != false ]]; then
  set -x
fi

# Defaults
declare -x branch=master
declare -x dry_run=false

# Source helper scripts
source ./greenbase.resolve_deps
source ./greenbase.config
source ./greenbase.opts
source ./greenbase.provider

get_green_hash() {
  hash="$(${scriptdir}/ci-providers/${provider})"
  echo $hash
}

rebase_after_pull() {
  [[ $($git config branch.autosetuprebase) -eq always ]] \
    || [[ $($git config pull.rebase) -eq true ]]
}

upstream_branch() {
  $git for-each-ref --format='%(upstream:short)' $($git symbolic-ref -q HEAD)
}

# Fetch the latest
branch=$($git rev-parse --abbrev-ref HEAD)

if [[ $branch -ne master ]]; then
  $git fetch origin master:master > /dev/null 2>&1
else
  $git fetch > /dev/null 2>&1
fi

greenhash=$(get_green_hash)
if [[ -z $greenhash ]]; then
  echo "Unable to retrieve latest green build." >&2
  exit 1
fi

if ! $git cat-file -e $greenhash; then
  echo "${greenhash} not found in local repository. Check your configs." >&2
  exit 1
fi

if [[ $greenhash == $($git rev-parse master) ]]; then
  echo 'Already on the latest green build. Tidying up.'
fi

echo "Latest green build: $($git log -1 --oneline $greenhash)"

echo -n "Resetting master to match "
# Update origin/master to match greenhash
$git update-ref refs/remotes/origin/master $greenhash

if [[ $branch == master ]]; then
  [[ $dry_run == false ]] && $git reset --hard $greenhash
else
  # Update master to match greenhash
  $git update-ref refs/heads/master $greenhash
  if rebase_after_pull && [[ ! -z upstream_branch ]]; then
    echo "and rebasing ${branch} onto master"
    [[ $dry_run == false ]] && $git pull --rebase > /dev/null 2>&1
  fi
fi

